---
layout: post
title: 【面试】边边角角（二）
tags: interview
---

#### 1. MVCC

链式存储结构，包含一个修改版本号，一个删除版本号。序号递增。

| 隔离级别 | 读数据一致性                           | 脏读 | 不可重复读 | 幻读 |
| -------- | -------------------------------------- | ---- | ---------- | ---- |
| 未提交读 | 最低级别，只保证不读取物理上损坏的数据 | 有   | 有         | 有   |
| 已提交读 | 语句级                                 | 无   | 有         | 有   |
| 可重复读 | 事务级                                 | 无   | 无         | 有   |
| 可串行化 | 最高级别，事务级                       | 无   | 无         | 无   |

默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：

- SELECT：读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的
- INSERT：将当前事务的版本号保存至行的创建版本号
- UPDATE：新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
- DELETE：将当前事务的版本号保存至行的删除版本号

#### 2. 算法：找出数组中每个数右边第一个比它大的元素，单调栈解法

```go
func findMaxRightWithStack(nums []int) []int {
	if len(nums) == 0 { return nil }
	size := len(nums)
	result := make([]int, size)
	stack := make([]int, 0) stack = append(stack, 0) # 创建栈，入栈
	idx := 1
	for idx < size { if len(stack) != 0 && nums[idx] > nums[stack[len(stack)-1]] {
			result[stack[len(stack)-1]] = nums[idx]
			stack = stack[:len(stack) - 1] } else { stack = append(stack, idx)
			idx ++ } }
	if len(stack) != 0 { result[stack[len(stack) - 1]] = -1
		stack = stack[:len(stack) - 1] } return result }
```

#### 3. 算法：买卖股票的最佳时机（Leetcode121）

```go
func maxProfit(prices []int) int {
    if len(prices) < 2 { return 0 }
    dp := make([][2]int, len(prices))
    dp[0][0] = 0 dp[0][1] = -prices[0]
    for i:=1; i<len(prices); i++ { dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        dp[i][1] = max(dp[i-1][1], -prices[i]) } return dp[len(prices)-1][0] } 
```

> 补充问题：
>
> 不限制次数
>
> ```go
> dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
> dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
> ```
>
> 有一天冷却期
>
> ```go
> for i:=0; i<pLen; i++{ if i-1 == -1{ dp[i][0]=0
>          dp[i][1]=-prices[i] continue }
>      if i-1 == 0 { dp[i][0]=max(dp[i-1][0], dp[i-1][1]+prices[i])
>          dp[i][1]=max(dp[i-1][1], -prices[i]) continue }
>      dp[i][0]=max(dp[i-1][0], dp[i-1][1]+prices[i])
>      dp[i][1]=max(dp[i-1][1], dp[i-2][0]-prices[i]) }
> ```
>
> 有服务费
>
> ```go
> dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
> dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
> ```
>
> 两次买卖
>
> ```go
> func maxProfit(prices []int) int { maxK := 2
>  n := len(prices)
>  dp := make([][][2]int, n)
>  for i:=0; i<len(dp); i++ { dp[i] = make([][2]int, maxK+1) }
>  for i:=0; i<n; i++ { for k:=maxK; k>=1; k-- { if i-1 == -1 { dp[i][k][0] = 0
>              dp[i][k][1] = -prices[i] continue }
>          dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
>          dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) } }
>  return dp[n-1][maxK][0] }
> ```

#### 4. 算法：跳跃游戏（Leetcode55）

```go
func canJump(nums []int) bool {
    if len(nums) == 0 { return true }
    f := make([]bool, len(nums)) f[0] = true # 动态规划数组
    for i := 1; i < len(nums); i++ { for j := 0; j < i; j++ {
            if f[j] == true && nums[j]+j >= i { f[i] = true } } }
    return f[len(nums)-1] }
```

> 最小次数
>
> ```go
> func jump(nums []int) int {
>  f := make([]int, len(nums)) f[0] = 0
>  for i := 1; i < len(nums); i++ { f[i] = i
>      for j := 0; j < i; j++ { if nums[j]+j >= i { f[i] = min(f[j]+1,f[i]) } } }
>  return f[len(nums)-1] }
> ```

#### 5. 算法：合并排序的数组（面试10.01）

```go
func merge(A []int, m int, B []int, n int)  {
    i, j, index := m - 1, n - 1, len(A) - 1
    for i >= 0 && j >= 0 {
        if A[i] >= B[j] { A[index] = A[i]
            i-- } else { A[index] = B[j]
            j-- } index-- } if j >= 0 { copy(A[:j+1], B[:j+1]) } }
```

#### 6. 算法：剪绳子（剑指offer-14）

```go
// 动态规划
func cuttingRope(target int) int {
    if target == 2 { return 1 }
    if target == 3 { return 2 }
    if target == 4 { return 4 }
    dp := make([]int, target + 1)
    dp[1], dp[2], dp[3] = 1, 2, 3
    res := 0
    for i:=4; i<=target; i++{for j:=1; j<=i/2; j++ {res = max(res, dp[j] * dp[i-j])}
        dp[i] = res } return dp[target] }
```

#### 7. 算法：链表相交（面试02.07）

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	p1, p2 := headA, headB
	for p1 != p2 { if p1 == nil { p1 = headB } else { p1 = p1.Next }
		if p2 == nil { p2 = headA } else { p2 = p2.Next } } return p1 }
```

#### 8. 二叉树最近公共祖先（注：多叉树公共祖先）（Leetcode236）

```go
# 递归
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil { return nil }
    if root.Val == p.Val || root.Val == q.Val { return root }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left != nil && right != nil { return root }
    if left == nil { return right }
    return left }
# 非递归
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    parent := map[int]*TreeNode{}
    visited := map[int]bool{}
    var dfs func(*TreeNode)
    dfs = func(r *TreeNode) { if r == nil { return }
        if r.Left != nil { parent[r.Left.Val] = r
            dfs(r.Left) }
        if r.Right != nil { parent[r.Right.Val] = r
            dfs(r.Right) } }
    dfs(root)
    for p != nil { visited[p.Val] = true
        p = parent[p.Val] }
    for q != nil { if visited[q.Val] { return q } q = parent[q.Val] } return nil }
```

#### 9. 算法：二叉树中的最大路径和（Leetcode124）（任意节点）

```go
var res int
func maxPathSum(root *TreeNode) (sum int) { if root == nil { return 0 }
	res = -1 << 63 //用来判断 所有节点都是负数时，应返回哪一个。
	dfs(root)
	return res }
func dfs(root *TreeNode) (sum int) { if root == nil { return }
	lMax := max(0, dfs(root.Left))     //左分支 最大贡献
	rMax := max(0, dfs(root.Right))    //右分支 最大贡献
	res = max(res, root.Val+lMax+rMax) //与当前结果对比
	return root.Val + max(lMax, rMax)  //返回单分支最大值 }
func max(nums ...int) int { max := -1 << 63
	for _, v := range nums { if v > max { max = v } } return max }
```

#### 10. 二叉树的路径中（根-叶子）最小值（最大改一下就ok）

```go
func minSum(root *TreeNode) int { if root == nil { return 0 }
    if root.Left != nil && root.Right != nil {
        return root.Val + min(minSum(root.Left), minSum(root.Right)) } else {
        if root.Left == nil { return root.Val + minSum(root.Right) } else {
            return root.Val + minSum(root.Left) } } }
```

#### 11. 算法：最长连续递增序列（Leetcode128）（哈希表）

```go
func longestConsecutive(nums []int) int {
    numSet := map[int]bool{}
    for _, num := range nums { numSet[num] = true }
    longestStreak := 0
    for num := range numSet { if !numSet[num-1] { currentNum := num
            currentStreak := 1
            for numSet[currentNum+1] { currentNum++
                currentStreak++ }
            if longestStreak < currentStreak { longestStreak = currentStreak } } }
    return longestStreak }
```

#### 12. 算法：接雨水（双指针）（Leetcode42）

```go
func trap(height []int) int {
	var left, right, leftMax, rightMax, res int
	right = len(height) - 1
	for left < right { if height[left] < height[right] {
			if height[left] >= leftMax { leftMax = height[left] } else {
				res += leftMax - height[left] } left++ } else {
			if height[right] > rightMax { rightMax = height[right]  } else {
				res += rightMax - height[right]  } right-- } } return res }
```

#### 13. 算法：螺旋矩阵 （Leetcode 59）

```go
func generateMatrix(n int) [][]int {
    result:=[][]int{}
    for i:=0;i<n;i++{ result=append(result,make([]int,n)) }
    size:=n*n
    a, b, c, d:=0,n-1, 0, n-1      //左右边界,上下边界
    idx:=1
    for idx<=size{ for i:=a;i<=b;i++ { result[c][i]=idx
            idx++ } c++     //上边界收缩
        for i:=c;i<=d;i++ { result[i][b]=idx
            idx++ } b--     //右边界收缩
        for i:=b;i>=a;i-- { result[d][i]=idx
            idx++ } d--     //。。。
        for i:=d;i>=c;i--{ result[i][a]=idx
            idx++ } a++} return result }
```

> 矩阵不是正方形的
>
> ```go
> func spiralOrder(matrix [][]int) []int {
>     if len(matrix) == 0 || len(matrix[0]) == 0 { return []int{} }
>     up, low, left, right := 0, len(matrix) - 1, 0, len(matrix[0]) - 1
>     order := make([]int, len(matrix) * len(matrix[0]))
>     index := 0
>     for left <= right && up <= low { for i:=left; i<=right; i++ { 
>             order[index] = matrix[up][i]
>             index ++ }
>         for j:=up+1; j<=low; j++ { order[index] = matrix[j][right]
>             index ++ }
>         if left < right && up < low { for i:=right-1; i>left; i-- {
>                 order[index] = matrix[low][i]
>                 index ++ }
>             for j:=low; j>up; j-- { order[index] = matrix[j][left]
>                 index ++ } }
>         left++
>         right--
>         up++
>         low-- } return order }
> ```

#### 14. 算法：重建二叉树（剑指offer-07）

```go
func buildTree(preorder []int, inorder []int) *TreeNode {
    for i:=0; i<len(inorder); i++ {
        if inorder[i] == preorder[0] { return &TreeNode { Val: preorder[0],
                Left: buildTree(preorder[1:i+1], inorder[0:i]),
                Right: buildTree(preorder[i+1:], inorder[i+1:]), } } } return nil }
```

#### 15. 算法：路径总和（Leetcode 112）

```go
func hasPathSum(root *TreeNode, sum int) bool {
	if root == nil { return false }
	if root.Left == nil && root.Right == nil { return sum == root.Val }
	return hasPathSum(root.Left,sum-root.Val) || hasPathSum(root.Right,sum-root.Val) }
```

> 输出精确路径
>
> ```go
> var res [][]int
> func pathSum(root *TreeNode, sum int) [][]int { res = [][]int{}
> 	dfs(root, sum, []int{}) return res }
> func dfs(root *TreeNode, sum int, stack []int) { if root == nil { return }
> 	stack = append(stack, root.Val)
>  	if root.Left == nil && root.Right == nil { if sum == root.Val {
>       		r := make([]int, len(stack))
>          	copy(r, stack)
>          	res = append(res, r) } }
>  	dfs(root.Left, sum-root.Val, stack)
>  	dfs(root.Right, sum-root.Val, stack) }
> ```

#### 16. 单例模式

* 懒汉式，线程不安全

```go
type SingTon struct {}
var instance *SingTon
func TestLazy(t *testing.T) *SingTon { if instance == nil { instance = &SingTon{} }
    return instance }
```

* 加锁模式

```go
type SingTon struct {}
var instance *SingTon
var mu sync.Mutext
func TestLazy(t *testing.T) *SingTon { mu.Lock()
    defer mu.Unlock()
    if instance == nil { instance = &SingTon{} } return instance }
//-------------------------------------------------//
var oSingle sync.Once
func TestLazy(t *testing.T) *SingTon { oSingle.Do()
    if instance == nil { instance = &SingTon{} } return instance }
```

* 饿汉式

```go
type SingTon struct {}
var instance *SingTon
func init() { instance = &SingTon{} }
//----------------------------------//
var instance *SingTon = new(SingTon)
func TestLazy(t *testing.T) *SingTon { return instance }
```

#### 17. 合并区间（Leetcode 56）

```go
func merge(intervals [][]int) [][]int {
	sort.Slice(intervals, func(i,j int)bool{ return intervals[i][0]<intervals[j][0] })
	var result [][]int
	for i := 0; i < len(intervals);i++ {
		if len(result) == 0 || intervals[i][0] > result[len(result)-1][1] {
			result = append(result,intervals[i])
		} else if intervals[i][1] > result[len(result)-1][1]{
			result[len(result)-1][1] = intervals[i][1] } } return result }
```

#### 18. 和为 s 的连续正数序列（剑指 offer 57 II）

```go
func findContinuousSequence(target int) [][]int {
	if target <= 0 { return [][]int{} }
	i, j := 1, 1
	sum := 0
	result := [][]int{}
	for i <= target/2+1 { if sum < target { sum += j
			j++ } else { sum = sum - i 
            i++ }
		if sum == target { tmp := []int{}
			for k := i; k < j; k++ { tmp = append(tmp, k) }
			result = append(result, tmp)
			sum = sum - i
			i++ } } return result }
```

#### 19. 数据库连接池

需要考虑的事情有：

- 限制连接池中最多、可以容纳的连接数目，避免过度消耗系统资源
- 设置连接池中允许空闲状态的连接时的最大个数
- 饱和策略，一种是等待，另一种是为客户分配一个新的临时连接
- 归还用完的链接

#### 20. 算法：最接近和的子数组

```go
type P struct{ sum, index int }
type PList []*P
func (list PList) Len() int{ return len(list) }
func (list PList) Less(i, j int) bool{ return list[i].sum < list[j].sum }
func (list PList) Swap(i, j int){ list[i], list[j] = list[j], list[i] }
func abs(x int) int{ if x >= 0{ return x } return -x } 
func subarraySum(nums []int, k int) (int, int) { sum := 0
	list := PList{}
	p := new(P)
	p.sum = 0
	p.index = -1
	list=append(list, p)
	for i,v := range nums{ sum += v
		p := new(P)
		p.sum = sum
		p.index = i
		list=append(list, p) }
	sort.Sort(list)
	min, f, b:= 1000000, 0, 0
	for i,v := range list{ if i==0 { continue }
		cur := abs(v.sum - list[i-1].sum - k)
		if cur < min{ min = cur
			f = list[i-1].index - 1
			b = list[i].index } } return f,b }
```

#### 21. 场景题：分布式生成数据

1. `Snowflower`算法：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。
2. `Redis`：可以用`Redis`的原子操作`INCR`和`INCRBY`来实现。

#### 22. 算法：输出下一个更大的数字

```go
func nextNumber(num int) int {
    chars := []byte(strconv.Itoa(nums))
    outter:
    for i:=len(chars)-1; i>0; i-- { for j:=i-1; j>=0; j-- {
            if chars[i] > chars[j] { chars[i], chars[j] = chars[j], chars[i] 
            break outter } } }
	rlt := strconv.Atoi(string(chars)) return rlt }
```

#### 23. 算法：缺失的第一个正数（Leetcode41）

```go
func firstMissingPositive(nums []int) int {
    n := len(nums)
    for i := 0; i < n; i++ {
        for nums[i] > 0 && nums[i] <= n && nums[nums[i]-1] != nums[i] {
            nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1] } }
    for i := 0; i < n; i++ { if nums[i] != i + 1 { return i + 1 } } return n + 1 }
```

#### 24. 场景题：抛硬币问题

只要保证两个人喝水的概率一直即可。将硬币抛两次，那么出现情况的概率如下：

| 情况         | 正（第一次） | 反（第一次） |
| ------------ | ------------ | ------------ |
| 正（第二次） | 0.49         | 0.21         |
| 反（第二次） | 0.21         | 0.09         |

那么显然，只要让两个一正一反的情况出现时让他们分别喝水，否则重抛即可。

#### 25. 算法：有序有重复数组查找范围（Leetcode34）

```go
func searchRange(nums []int, target int) []int {
    left, right := -1, -1
    if len(nums) == 0 || nums[len(nums) - 1] < target { return []int{left,right} }
    for i := 0; i < len(nums); i++ { if nums[i] == target { left = i } }
    for j := len(nums) - 1; j >= 0 ; j-- { if nums[j] == target { right = j } }
    return []int{right, left} }
```

#### 26. 算法：三数之和（Leetcode15）

```go
func threeSum(nums []int) [][]int {
	sort.Ints(nums
	var res [][]int
	length := len(nums)
	if len(nums) < 3 { return res }
	for index, value := range nums { if nums[index] > 0 { return res }
		if index > 0 && nums[index] == nums[index-1] { continue }
		l, r := index + 1, length - 1
		for l < r { sum := value + nums[l] + nums[r]
			switch { case sum == 0:
				res = append(res, []int{nums[index], nums[l], nums[r]})
				for l < r && nums[l] == nums[l+1] { l += 1 }
				for l < r && nums[r] == nums[r-1] { r -= 1 }
				l += 1
				r -= 1
			case sum > 0: r -= 1
			case sum < 0: l += 1 } } } return res }
```

#### 27. 二维码登录流程

1. 用户 A 访问微信网页版，微信服务器为这个会话生成一个全局唯一的 ID，上面的 URL 中 `obsbQ-Dzag==` 就是这个 ID，此时系统并不知道访问者是谁。

2. 用户A打开自己的手机微信并扫描这个二维码，并提示用户是否确认登录。

3. 手机上的微信是登录状态，用户点击确认登录后，手机上的微信客户端将微信账号和这个扫描得到的 ID 一起提交到服务器

4. 服务器将这个 ID 和用户 A 的微信号绑定在一起，并通知网页版微信，这个 ID 对应的微信号为用户 A，网页版微信加载用户 A 的微信信息，至此，扫码登录全部流程完成

#### 28. 马在棋盘上的概率（Leetcode688）

```go
func knightProbability(N int, K int, r int, c int) float64 {
    moves := [][]int{{-2, -1},{-2, 1},{-1, -2},{-1, 2},{1, -2},{1, 2},{2, -1},{2, 1}}
    temp, dp := make([][]float64, N), make([][]float64, N)
    for i := 0; i < N; i++ {
	    temp[i], dp[i] = make([]float64, N), make([]float64, N)
	    for j := 0; j < N; j++ { dp[i][j] = 1 } }
    for m := 1; m <= K; m++ { for i := 0; i < N; i++ { for j := 0; j < N; j++ {
		        for _, move := range moves { nextX, nextY := i+move[0], j+move[1]
		            if nextX < 0 || nextX >= N || nextY < 0 || nextY >= N {continue}
		            temp[i][j] += dp[nextX][nextY] } temp[i][j] /= 8 } }
	    for i := 0; i < N; i++ {
	        for j := 0; j < N; j++ { dp[i][j], temp[i][j] = temp[i][j], 0 } } }
    return dp[r][c] }
```

#### 29. 算法：加油站（Leetcode 134）

```go
func canCompleteCircuit(gas []int, cost []int) int {
	n := len(gas)
	left := make([]int, n, n)
    totalSum := 0
	for i := 0; i < n; i++ { left[i] = gas[i] - cost[i]
        totalSum += left[i] }
    if totalSum < 0 { return -1 }
	start := 0
	sum := 0
	for i := 0; i < n; i++ { if sum < 0 { start = i
			sum = 0 }
		sum += left[i] } return start }
```

#### 30. 柠檬水（Leetcode 860）

```go
func lemonadeChange(bills []int) bool {
	five, ten := 0, 0
	for _, v := range bills { if v == 5 { five ++
		} else if v == 10 { if five >= 1 { five --
				ten ++ } else { return false }
		} else if v == 20 { if five >= 1 && ten >= 1 { five --
				ten --
			} else if five >= 3 { five -= 3 } else { return false } } } return true }
```

#### 31. 圆圈中剩下的数字（剑指 offer 62）

```go
func f(n, m int) int {
	if n == 1 { return 0 }
	x := f(n-1, m)
	return (m + x) % n }
func lastRemaining(n int, m int) int { return f(n, m) }
```

#### 32. 和为 k 的连续子数组的个数（Leetcode 560）

```go
func subarraySum(nums []int, k int) int {
    if len(nums)==0{ return 0 }
    count:=0
    for i:=0;i<len(nums);i++ { cur:=nums[i]
        if cur == k { count++ }
        for j:=i+1;j<len(nums);j++{ t:=nums[j]
            cur+=t
            if cur==k{ count++ } } } return count }
```

#### 33. 数字序列中某一位的数字（第一位没有0）

```go
func findNthDigit(n int) int {
	digits:=1
	flag:=9
	for n-flag*digits>0{ n=n-flag*digits
		flag=flag*10
		digits++ }
	if digits==1{ return n }
	number:=1
	for k:=1;k<digits;k++{ number=number*10	}
	number=number+(n-1)/digits
	idx:=(n-1)%digits 
	strnums:=strconv.Itoa(number)
	res,_:=strconv.Atoi(string(strnums[idx]))
	return res }
```

#### 34. 求中位数，数组从某一位被截断

```go
func findMedian(nums []int) float64 {
    loc := 0
    for i:=1; i<len(nums); i++ { if nums[i] < nums[i-1] { loc = i - 1
            break } }
    sub := len(nums) - 1 - loc
    if len(nums) % 2 == 0 { return float64(nums[(sub+len(nums)/2)/len(nums)]+nums[(sub+len(nums)/2+1)/len(nums)]) / float64(2.0) } else {
        return float64(nums[(sub+len(nums)/2)/len(nums)]) } }
```

#### 35. 三个线程循环打印 ABC

```go
func printc(c1 chan bool, c2 chan bool, s string) {
	if _, ok := <-c1; ok {
		fmt.Println(s)
		c2 <- true } }
func main() {
	c1 := make(chan bool, 1)
	c2 := make(chan bool)
	c3 := make(chan bool)
	defer func() { close(c1) close(c2) close(c3)
		fmt.Println("end") }()
	c1 <- true
	for range make([]struct{}, 5) {
		go printc(c1, c2, "a")
		go printc(c2, c3, "b")
		go printc(c3, c1, "c")
		time.Sleep(time.Second) } }
```

#### 36. 扑克牌

54张扑克牌，平均分成3份，大小王在一份的概率
$$
p = \frac{{C^{18}_{54}}\times{C^{18}_{36}}\times{C^{18}_{18}}}{{C^{1}_{3}}\times{C^{16}_{52}}\times{C^{18}_{36}}\times{C^{18}_{18}}}
$$

#### 37. 有序数组中不重复元素的个数

```go
func squareUniqueNum(nums []int) int { length := len(nums)
    if length < 2 { return length }
    sum, left, right := 0, 0, length - 1
    for left <= right { if nums[left] + nums[right] == 0 { sum ++
            temp := nums[left]
            for left <= right && nums[left] == temp { left ++ }
            for left <= right && nums[right] == -temp { right -- }
        } else if nums[left] + nums[right] < 0 { sum ++
            temp := nums[left]
            for left <= right && nums[left] == temp { left ++ }
        } else { sum ++
            temp := nums[right]
            for left <= right && nums[right] == temp { right -- } } } return sum }
```

#### 38. **一个数据先递增再递减，找出数组不重复的个数**

```go
func squareUniqueNum(nums []int) int { length := len(nums)
    if length < 2 { return length }
    sum, left, right := 0, 0, length - 1
    for left <= right { if nums[left] == nums[right] { sum ++
            temp := nums[left]
            for left <= right && nums[left] == temp { left ++ }
            for left <= right && nums[right] == temp { right -- }
        } else if nums[left] < nums[right] { sum ++
            temp := nums[left]
            for left <= right && nums[left] == temp { left ++ }
        } else { sum ++
            temp := nums[right]
            for left <= right && nums[right] == temp { right -- } } } return sum }
```

#### 39. 二叉搜索树的第K大节点（Leetcode 54）

```go
var skip int
var res int
func kthLargest(root *TreeNode, k int) int { skip = k
    res = 0
    dfs(root)
    return res }
func dfs(root *TreeNode) { if root != nil{ dfs(root.Right)
        skip--
        if skip == 0{ res = root.Val
            return }
        dfs(root.Left) } }
```

#### 40. 求平方根

```go
# 带精度
func fn(n, e float64) float64 {
    x := 0.0
    if n > 0 && e > 0 {
        low, high := 0.0, n
        for low < high { mid := (low + high) / 2.0
            if mid * mid < n - e { low = mid } else if mid * mid > n + e {
                high = mid } else { x = mid
                break } } } return x }
# 牛顿迭代法
func mySqrt(x int) int { var a int = x
    for a * a > x { a = (a + x / a) / 2 } return a }
```

#### 41. 翻转字符串中的单词

```go
func reverseWords(s string) string {
    if s == "" { return "" }
    s = PreProcess(s) 
    wordarry := strings.Split(s, " ") 
    i, j := 0, len(wordarray) - 1
    for i < l { wordarry[i], wordarry[l] = wordarry[l], wordarry[i]
        i++
        l-- }
    res := strings.Join(wordarry, " ")   // 连接
    return res }
func PreProcess(s string) string {
    l := len(s)
    var res []byte
    flag := 1   // 用于处理多个连续空格
    for l != 0 && s[l - 1] == ' ' { l-- }
    for i := 0; i < l; i++ { if s[i] != ' ' { res = append(res, s[i]) flag = 0 }
        if s[i] == ' ' && flag == 0 { res = append(res, s[i])
            flag = 1 } } return string(res) }
```

#### 42. 版本号比较

```go
var ( version0 = 0
	version1 = 1
	version2 = 2 )
func StrTrimSpace(v1str,v2str string )(v1,v2 string ){ v1=strings.TrimSpace(v1str)
	v2=strings.TrimSpace(v2str)
	return }
func comparSlice(v1slice,v2slice []string )int{
	for index,_ :=range v1slice{
		if v1slice[index] > v2slice[index]{ return version1 }
		if v1slice[index] < v2slice[index]{ return version2 }
		if len(v1slice)-1 == index { return  version0 } } return  version0 }
func comparSlice1(v1slice,v2slice []string,flas int  )int{
	for index,_ :=range v1slice{ if v1slice[index] > v2slice[index]{
			if flas == 2{ return version2 } return version1 }
		if v1slice[index] < v2slice[index]{ if flas == 2{ return version1 }
			return version2 }
		if len(v1slice)-1 == index {
			if flas == 2{ return version1 }else if flas == 1{ return version2 }}}
	return  version0 }
func compareStrVer(v1,v2 string)(res int ){
	s1, s2 := StrTrimSpace(v1, v2)
	v1slice := strings.Split(s1,".")
	v2slice := strings.Split(s2,".")
	if len(v1slice) != len(v2slice){ if len(v1slice) > len(v2slice){
			res=comparSlice1(v2slice,v1slice,2)
			return res }else{ res=comparSlice1(v1slice,v2slice,1)
			return res } }else{ res = comparSlice(v1slice, v2slice) } return res }
```

#### 43. 求完全二叉树节点的个数（Leetcode222）

```go
func countNodes(root *TreeNode) int {
    if root == nil { return 0 }
    left := countLevel(root.Left)
    right := countLevel(root.Right)
    if left == right { return countNodes(root.Right) + (1 << left) } else {
        return countNodes(root.Left) + (1 << right) } }
func countLevel(root *TreeNode) int {
    level := 0
    for root != nil { level ++
        root = root.Left }
    return level }
```

#### 44. 二叉树的右视图（Leetcode 199）

```go
func rightSideView(root *TreeNode) []int {
    if root==nil{ return nil }
    ans:=make([]int,0)
    q:=make([]*TreeNode,0)
    q=append(q,root)
    for len(q)!=0 { level:=len(q)
        for i:=0;i<level;i++{ v:=q[0]
            q=q[1:]
            if i==level-1{ ans=append(ans,v.Val) }
            if v.Left!=nil{ q=append(q,v.Left) }
            if v.Right!=nil{ q=append(q,v.Right) } } } return ans }
```

#### 45. 通用求解 Partition 函数

```go
func partition(left int, right int, list []int) (int) {
    i, left := left, right
    temp := list[left]
    for i != j { for i < j && list[j] >= temp { j-- }
        for i < j && list[i] <= temp { i++ }
        if i < j { list[i], list[j] = list[j], list[i] } }
    list[left], list[i] = list[i], list[left]　　 
    return i }
```

#### 46. 把数字翻译成字符串

```go
func translateNum(num int) int {
    src := strconv.Itoa(num)
    count := 0
    length := len(src)
    counts := make([]int, length)
    for i:=len(src)-1; i>=0; i-- { count = 0
        if i < length - 1 { count = counts[i+1] } else { count = 1 }
        if i < length - 1 { tmp := src[i:i+2]
            if tmp <= "25" && tmp >= "10" { if i < length - 2 { count += counts[i + 2]
                } else { count += 1 } } } counts[i] = count } count = counts[0]
    return count }
```

#### 47. 最长不含重复字符的子字符串（剑指offer-48）

```go
func lengthOfLongestSubstring(s string) int {
    if s == " " { return 1 }
    arr := make(map[string]int, 0)
    var tmp string
    for _, v := range s { for i2,v2 := range tmp { if v2 == v { arr[tmp] = len(tmp)
                tmp = tmp[i2 + 1 : ] } } tmp = tmp + string(v) }
    arr[tmp] = len(tmp)
    var max int = 0
    for _,v := range arr { if max < v { max = v } } return max }
```

#### 48. 丑数（剑指offer-49）

```go
func nthUglyNumber(n int) int {
    if n == 1 { return 1 }
    result := make([]int, 0)
    result = append(result, 1)
    res := 0
    i, j, k := 0, 0, 0
    for n > 1 { x := result[i] * 2
		y := result[j] * 3
		z := result[k] * 5
		res = min(min(x, y), z)
		if res == x { i++ }
		if res == y { j++ }
		if res == z { k++ }
		result = append(result, res)
		n-- } return result[len(result) - 1] }
```

#### 50. 数组中的逆序对

```go
var count=0
func reversePairs(nums []int) int { count=0
    megerSortCount(nums)
    return count }
func megerSortCount(nums []int) []int{
    if len(nums)<=1 { return nums } else { mid:=len(nums)/2
        leftList:=megerSortCount(nums[:mid])
        rightList:=megerSortCount(nums[mid:])
        res:=[]int{}
        i,j:=0,0
        for i<len(leftList)&&j<len(rightList){
            if leftList[i]<=rightList[j]{ res=append(res,leftList[i])
                i++ }else{ res=append(res,rightList[j]) j++
                count+=len(leftList)-i } }
        res=append(res,leftList[i:]...)
        res=append(res,rightList[j:]...)
        return res } }
```

#### 51. 数组中数字出现的次数

```go
func singleNumbers(nums []int) []int {
    var a int
    for i := range nums{  a ^= nums[i] }
    mask := a & (-a)
    res := make([]int,2)
    for _,v :=range nums{ if (v & mask) == 0{ res[0] ^= v }else{ res[1] ^= v } }
    return res }
```

#### 52. 求1+2+...+n（使用位运算）

```go
func sumNums(n int) int { _ = n > 0 && plus(&n, sumNums(n - 1)) return n }
func plus(a *int, b int) bool { *a += b
    return true }
```

#### 53. 构建乘积数组（剑指offer-66）

```go
func constructArr(a []int) []int {
    if len(a) <= 1 { return a }
    left, right := make([]int, len(a)), make([]int, len(a))
    left[0] = 1
    right[len(a) - 1] = 1 
    for i := 1; i < len(a); i++ { left[i] = left[i - 1] * a[i - 1] }
    for i := len(a) - 2; i >= 0; i-- { right[i] = right[i + 1] * a[i + 1] }
    arr := make([]int, len(a))
    for i := 0; i< len(a); i++ { arr[i] = left[i] * right[i] }
    return arr }
```

#### 54. 把字符串转换成数字

```go
func strToInt(str string) int {
    sig := true
    for len(str) != 0 { if str[0] == ' ' { str = str[1:] } else { break } }
    if len(str) == 0 { return 0 }
    var res int64 
    switch str[0] { case '-': sig = false case '+': break
        case '0','1','2','3','4','5','6','7','8','9':
            res = int64(str[0]) - 48
        default: return 0 }
    switch sig { case false: res = -res }
    for i := 1; i < len(str); i++ { if sig {
            if str[i] >= '0' && str[i] <= '9' { res = res * 10 + int64(str[i])-48
            if res > math.MaxInt32 { return math.MaxInt32 } } else { break }
        } else { if str[i] >= '0' && str[i] <= '9' {
                res = res * 10 - (int64(str[i] - 48))
                if res < math.MinInt32 { return math.MinInt32 } } else { break }}}
    return int(res) }
```

#### 55. 找出重复元素

```go
func findDuplicated(nums []int) int {
    min, max := 0, 0
    for i:=0; i<len(nums); i++ { max = Max(max, nums[i])
        min = Min(min, nums[i]) }
    length := max/8-min/8+1
    array := make([]int8, length)
    for i:=0; i<len(nums); i++ { num = nums[i]
        index := num/8-min/8
        k := (num-min)%8
        if array[index]&(1<<k) > 0 { return num } else { array[index] |= (1<<k)}}
    return -1}
```

#### 56. 最大子序和

```go
func maxSubArray(nums []int) int {
    if len(nums) == 0{ return 0 }
    result := nums[0]
    dp := make([]int, len(nums))
    for i:=0; i<len(dp); i++ { dp[i] = nums[i] }
    for i:=1; i<len(dp); i++ { dp[i] = max(dp[i-1]+nums[i], dp[i]) }
    for i:=0; i<len(dp); i++ { if result < dp[i] { result = dp[i] } }
    return result }
```

#### 57. 中文数字转阿拉伯数字

```go
var cnArr = []rune{'零', '一', '二', '三', '四', '五', '六', '七', '八', '九'}
var chArr = []rune{'十', '百', '千', '万', '亿'}
func ChineseNumToArabicNum(chineseNum string) int {
	result, temp, count := 0, 1, 0
	for i:=0; i<len([]rune(chineseNum)); i++ { b := true
		c := []rune(chineseNum)[i]
		for j:=0; j<len(cnArr); j++ { if c == cnArr[j] { if count != 0 {result += temp
					temp = 1
					count = 0 } temp = j
				b = false
				break } }
		if b == true { for j:=0; j<len(chArr); j++ { if c == chArr[j] { switch j {
					case 0: temp *= 10
					case 1: temp *= 100
					case 2: temp *= 1000
					case 3: temp *= 10000
					case 4: temp *= 100000000
					default: break } count++ } } } }
	result += temp
	return result }
```

#### 58. 红包设计

红包分配算法，随机，额度在0.01和剩余平均值*2之间。

```go
type Reward struct {
	Count          int   //个数
	Money          int   //总金额(分)
	RemainCount    int   //剩余个数
	RemainMoney    int   //剩余金额(分)
	BestMoney int   //手气最佳金额
	BestMoneyIndex int   //手气最佳序号
	MoneyList      []int //拆分列表 }
func GrabReward(reward *Reward) int {
	if reward.RemainCount <= 0 { panic("RemainCount <= 0") }
	if reward.RemainCount - 1 == 0 { money := reward.RemainMoney
		reward.RemainCount = 0
		reward.RemainMoney = 0
		return money }
	if (reward.RemainMoney / reward.RemainCount) == 1 { money := 1
		reward.RemainMoney -= money
		reward.RemainCount--
		return money }
	//最大可领金额 = 剩余金额的平均值x2 = (剩余金额 / 剩余数量) * 2
	maxMoney := int(reward.RemainMoney / reward.RemainCount) * 2
	rand.Seed(time.Now().UnixNano())
	money := rand.Intn(maxMoney)
	for money == 0 { money = rand.Intn(maxMoney) } reward.RemainMoney -= money
	if reward.RemainMoney < 0 { money += reward.RemainMoney
		reward.RemainMoney = 0
		reward.RemainCount = 0 } else { reward.RemainCount-- } return money }
```

#### 59. 浏览器输入URL并回车的过程以及相关协议

| 过程                                                         | 使用的协议            |
| ------------------------------------------------------------ | --------------------- |
| 1、浏览器查找域名DNS的IP地址 DNS查找过程（浏览器缓存、路由器缓存、DNS缓存） | DNS：获取域名对应的ip |
| 2、根据ip建立TCP连接                                         | TCP：与服务器建立连接 |
| 3、浏览器向服务器发送HTTP请求                                | HTTP：发送请求        |
| 4、服务器响应HTTP响应                                        | HTTP                  |
| 5、浏览器进行渲染                                            |                       |

#### 60. 重定向和转发的区别

**重定向：redirect**

 地址栏发生变化

 重定向可以访问其他站点（服务器）的资源

 重定向是两次请求。不能使用`request`对象来共享数据

 **转发：forward**

 转发地址栏路径不变

 转发只能访问当前服务器下的资源

 转发是一次请求，可以使用`request`对象共享数据

#### 61.  用户态和内核态

在计算机系统中，分两种程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态——用户态、内核态

**用户态：**只能受限的访问内存，运行所有的应用程序

**内核态：**运行操作系统程序，`cpu`可以访问内存的所有数据，包括外围设备

**用户态切换到内核态的3种方式：**

 a. 系统调用  b. 异常  c. 外围设备的中断

#### 62. 操作系统分配的进程空间

 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。

 堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。

 静态区（static）—存放全局变量和静态变量的存储

 代码区（text）—存放函数体的二进制代码。

 **线程共享堆区、静态区**

#### 63. 内存管理方式

**分段管理：**

 在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外部碎片（比如`4k`的段换`5k`的段，会产生`1k`的外碎片）

**分页管理：**

 在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：会产生内部碎片（一个页可能填充不满）

**段页式管理：**

段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲ 段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的。

#### 64. 死锁的条件

互斥条件、请求和保持条件、非剥夺条件、循环等待条件

#### 65. 事务4大特性及事务的隔离级别

原子性、一致性、隔离性、持久性

读未提交、读已提交、可重复读、串行化

#### 66. 索引 Innodb 和 Myisam 的区别以及场景

**Myisam：**支持表锁，适合读密集的场景，不支持外键，不支持事务，索引与数据在不同的文件

**Innodb：**支持行、表锁，默认为行锁，适合并发场景，支持外键，支持事务，索引与数据同一文件

#### 67. Innodb 支持的行级锁

 **记录锁（Record Lock）:** 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项。

 **间隙锁（Gap Lock）:** 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。

 **Next-key Lock：** 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。

#### 68. 回表查询和覆盖索引

普通索引 需要扫描两遍索引树

（1）先通过普通索引定位到主键值id=5；

（2）在通过聚集索引定位到行记录；

这就是所谓的**回表查询**，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。

**覆盖索引**：如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。

**实现覆盖索引**：常见的方法是，将被查询的字段，建立到联合索引里去。

#### 69. 创建索引的方法

```sql
ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL]  INDEX | KEY  [索引名] (字段名1 [(长度)] [ASC | DESC]) [USING 索引方法]；
########################################
CREATE  [UNIQUE | FULLTEXT | SPATIAL]  INDEX  索引名 ON  表名(字段名) [USING 索引方法]；
```

#### 70. 如何避免全表扫描

1. 对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引。

2. 应尽量避免在 where 子句中对字段进行 null 值判断

3. 应尽量避免在 where 子句中使用!=或<>操作符

4. `in` 和 `not in` 要慎用

#### 71. Explain 字段详解

| 列            | 含义                                         |
| ------------- | -------------------------------------------- |
| id            | 查询序号，序号越大越先执行，一样则按顺序执行 |
| select_type   | 查询类型，SIMPLE、PRIMARY、UNION、SUBQUERY等 |
| table         | 表名                                         |
| type          | join类型，const，eq_ref，ref等               |
| possible_keys | join类型                                     |
| key           | 实际选择的索引                               |
| ken_len       | 索引的长度                                   |
| ref           | 与索引作比较的列                             |
| rows          | 要检索的行数                                 |
| Extra         | 额外信息                                     |

#### 72. 三大范式

第一范式（1NF）列不可分割

第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]

第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]

#### 73. 主从复制

**原理：**：将主服务器的binlog日志复制到从服务器上执行一遍，达到主从数据的一致状态。

**过程：**从库开启一个I/O线程，向主库请求Binlog日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到中继日志（Relay log）中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍

**优点：**

- 作为备用数据库，并且不影响业务
- 可做读写分离，一般是一个写库，一个或多个读库，分布在不同的服务器上，充分发挥服务器和数据库的性能，但要保证数据的一致性

#### 74. 主从同步方式

异步复制、半同步复制、全同步复制

#### 75. 相互关注表设计

```sql
CREATE TABLE `tb_vip_follow` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `vip_id` bigint DEFAULT '0' COMMENT '用户ID(粉丝ID)',
  `followed_vip_id` bigint DEFAULT '0' COMMENT '关注的用户ID',
  `status` tinyint(1) DEFAULT '0' COMMENT '关注状态(0关注 1取消)',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `vip_followed_indx` (`vip_id`,`followed_vip_id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='会员关注关系表';
```

应用方式：

```sql
# 查找用户1的粉丝
select vip_id from tb_vip_follow where followed_vip_id = 1
# 查找用户1的关注
select followed_vip_id from tb_vip_follow where vip_id = 1
# 查看别人的粉丝或者关注列表
# 用内连接查找所有互粉
select a.* from tb_vip_follow as a inner join tb_vip_follow as b on a.followed_vip_id = b.vip_id and a.vip_id = b.followed_vip_id
# 用子查询查找用户
select followed_vip_id from tb_vip_follow where followed_vip_id in (select followed_vip_id from tb_vip_follow where vip_id = 1) and vip_id = 2
# 用子查询查找用户2和用户3的共同粉丝
select vip_id from tb_vip_follow where vip_id in (select vip_id from tb_vip_follow where followed_vip_id = 3) and followed_vip_id = 2
```

> 缺点：
>
> 1. 当用户量大时表数据量会非常庞大，因此必需要采用水平分表的方式将用户分散到多个表。
>
> 2. 每一次使用该表时都要将整条数据取出进行计算,对资源耗费太过严重。
>
> 3. 数据库瓶颈，并发受限。
>
> 改进：
>
> 使用`Redis`的`Hash`数据类型，每个用户分一张`hash`表。

#### 76. Redis 事务

`Redis` 事务的本质是通过`MULTI`、`EXEC`、`WATCH`等命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程中，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：`Redis`事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

`Redis`的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在`AOF`持久化模式下，并且`appendfsync`选项的值为`always`时，事务也具有耐久性。

**事务命令：**

**MULTI：**用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。

**EXEC：**执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。

**WATCH ：**是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。

**DISCARD：**调用该命令，客户端可以清空事务队列，并放弃执行事务，且客户端会从事务状态中退出。

**UNWATCH**：命令可以取消watch对所有key的监控。

#### 77. 如何保证缓存和数据库的数据一致性

**方式一：**

 读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

**方式二：**

 先更新数据库，假如读缓存失败，先读数据库，再回写缓存的方式实现

#### 78. Redis 单线程

1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。

2. 数据结构简单，对数据操作也简单，`Redis` 中的数据结构是专门进行设计的；

3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4. 使用多路 I/O 复用模型，非阻塞 IO；

#### 79. Redis 热 key

缓存中的一个`Key`在某个时间点过期的时候，恰好在这个时间点对这个`Key`有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

**解决方案：**

 对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。

#### 80. 2GB内存在20亿整数中找到出现次数最多的数

将20亿个数的大文件利用哈希函数分成16个小文件，根据哈希函数可以把20亿条数据均匀分布到16个文件上，同一种数不可能被哈希函数分到不同的小文件上，假设哈希函数够好。然后对每一个小文件用哈希函数来统计其中每种数出现的次数，这样我们就得到16个文件中出现次数最多的数，接着从16个数中选出次数最大的那个key即可。

#### 81. 40亿个非负整数中找到没有出现的数

使用位图解决该问题

#### 82. 40亿个非负整数中找到一个没有出现的数，内存限制10MB

1. 根据10MB的内存限制，确定统计区间的大小，就是第二次遍历时的bitArr大小。

2. 利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。

3. 对这个区间上的数做bit map映射，再遍历bit map，找到一个没出现的数即可。

#### 83. 40亿个无符号整数，1GB内存，找到所有出现两次的数

申请一个长度为`4294967295×2`的bit类型的数组`bitArr`，用2个位置表示一个数出现的词频，`1B`占用8个`bit`，所以长度为4294967295×2的`bit`类型的数组占用`1GB`空间。遍历这40亿个无符号数，如果初次遇到`num`，就把`bitArr[num*2 + 1]`和`bitArr[num*2]`设置为01，如果第二次遇到`num`，就把`bitArr[num*2+1]`和`bitArr[num*2]`设置为10，如果第三次遇到`num`，就把`bitArr[num*2+1]`和`bitArr[num*2]`设置为11。以后再遇到`num`，发现此时`bitArr[num*2+1]`和`bitArr[num*2]`已经被设置为11，就不再做任何设置。遍历完成后，再依次遍历`bitArr`，如果发现`bitArr[i*2+1]`和`bitArr[i*2]`设置为10，那么i 就是出现了两次的数。

#### 84. 飞机绕地球问题

第一阶段,加油机`A`和`B`分别在第`1/8`,`1/4`路程时只留够回程的油，并把油分给其他飞机。假设满油为`1`，则飞到`1/8`时，`A`返程，将`1/2`油平分给`B`和`1`号机；再飞行到`1/4`路程时，`B`留够`1/4`油，将`1/8`油分给`1`号机，这样`1`号机可以跑到`3/4`路程，由于地球是圆的，`A`和`B`在可以反方向出动接应`1`号机按第一阶段方法从`3/4`处到终点。

#### 85. 5L容器和6L容器盛3L水

用`5L`容器装满水倒进`6L`容器里，此时`6L`容器里还能装`1L`水，将`5L`容器再装满，倒进`6L`容器里，`5L`水只能倒进`1L`,所以还剩下`4L`,倒空`6L`容器，将`5L`容器的剩余`4L`水倒入，再将`5L`容器装满，倒入`6L`容器里，`6L`容器里只能再装入`2L`的水，所以，此时`5L`容器剩余`3L`水。

#### 86. 贪官偷金子问题

第一箱拿一块，第二箱拿两块，第三箱拿三块……第十箱拿十块。分别做标记。将这55块一起称重，总重量缺少几钱就是第几个箱子的黄金重量不足。

#### 87. 乒乓球问题

首先拿4个，以后就“看对手的脸色”，即他拿1个，你就拿5个，他拿2个，你就拿4个……总之就是从你对手开始拿球算起，你得使每个回合你们一共拿6个球。这样，到了最后就肯定是剩下6个球。最后一次，你对手至少得拿1个，至多5个，而你拿剩下的球就行。

#### 88. 圆桌射击游戏

<img src="https://uploadfiles.nowcoder.com/images/20190810/54836329_1565441511755_6FB53C51539B47559CF0D122A832CF63" alt="img" style="zoom:200%;" />

#### 89. 丈夫偷情问题

这是一个典型的递归问题。一旦所有的妻子都知道至少有一个男人出轨，我们就可以按递归方式来看待这个流程。先让我们假设只有一个丈夫偷情。则他的妻子见不到任何偷情的男人，因此知道这个人就是自己丈夫，她当天就会杀了他。假如有两个丈夫偷情，则他俩的妻子只知道不是自己丈夫的那一个男人偷情。因此她会等上一天看那个人有没有被杀死。假如第一天没人被杀死，她就能确定她自己的丈夫也偷了情。依此类推，假如有100个丈夫偷情，则他们能安全活上99天，直到100天时，所有妻子把他们全都杀死。

#### 90. 过桥问题（电池17分钟，四个人分别为1、2、5、10分钟）

1和2一起过（2分钟）；1返回（3分钟）；5和10一起过（13分钟）；2返回（15分钟）；1和2一起过（17分钟）。全体安全过桥。

#### 91. 手算$ 2^{64} $

2的10次方是1024，接近1000，估算做1000。所以2的60次方就是1000的6次方，也就是10的18次方。接下来还剩2的64-60=4次方，直接就是16。乘以之前的，直接估算成`1.6*10`的`19`次方了。但是有问题，之前把1024当作1000，引入了2.4%的误差对不对？那就一定要修正回来。根据泰勒展开，那么6次方后误差就会累积变成大约`6*2.5%=15%`。因此还要加回去`15%`，所以1.6多15%就是`1.84*10`的`19`次方。

#### 92. 打开一个文件，操作系统做了什么

当我们打开一个文件时，主要涉及了进程，文件描述符，文件描述表，打开文件表，目录项，索引表之间的联系。

1. 用户输入命令，shell进程被唤醒，对命令进行解析
   1. 用户敲击键盘，键入的信息记录在终端设备文件（tty0）上
   2. 敲击键盘后，还要产生键盘中断信号，系统对键盘中断信号进行处理
   3. 中断执行后，唤醒shell进程，通过进程调度机制，由进程0切换到shell进程
   4. shell进程通过执行自己的程序从（tty0）这个终端设备文件上读取用户键入的指令信息，然后解析该指令，并准备进行相应的处理

2. shell程序解析出用户命令后，调用`fork`函数创建一个用户进程，以便对`hello world`文件的程序进程控制

3. 新进程创建完毕后，加载hello world文件对应的程序
4. hello world程序开始执行，将“hello world”字符串显示在屏幕上

操作系统的一部分任务是为应用程序的运行提供使用硬盘、显示器、键盘灯外设的基础程序，应用程序就必须写这些程序，而且所有应用程序都要写的这部分程序的内容也都差不多。所有，我们也可以把操作系统看成所有应用程序共有的部分。

#### 93. 内核态与用户态

- 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。**因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；**

- 当程序运行在0级特权级上时，就可以称之为运行在内核态。

- 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。

- 这两种状态的主要差别是

  > - 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的
  > - 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

#### 94. 快排

```go
func QuickSort(nums []int) []int { quickSort(nums, 0, len(nums)-1)
    return nums }
func quickSort(nums []int, start, end int) {
    if start < end { pivot := partition(nums, start, end)
        quickSort(nums, 0, pivot-1)
        quickSort(nums, pivot+1, end) } }
func partition(nums []int, start, end int) int {
    p := nums[end]
    i := start
    for j := start; j < end; j++ { if nums[j] < p { nums[i], nums[j] = nums[j], nums[i] i++ } }
    nums[i], nums[end] = nums[end], nums[i]
    return i }
```

如果想要提升效率，可以考虑使用随机选择一个节点。

#### 95. 归并排序

```go
func MergeSort(nums []int) []int { return mergeSort(nums) }
func mergeSort(nums []int) []int { if len(nums) <= 1 { return nums }
    mid := len(nums) / 2
    left := mergeSort(nums[:mid])
    right := mergeSort(nums[mid:])
    result := merge(left, right)
    return result }
func merge(left, right []int) (result []int) {
    l, r := 0, 0
    for l < len(left) && r < len(right) { if left[l] > right[r] {
            result = append(result, right[r])
            r++ } else { result = append(result, left[l]) l++ } }
    result = append(result, left[l:]...)
    result = append(result, right[r:]...)
    return }
```

#### 96. 堆排序

```go
func HeapSort(a []int) []int {
	for i := len(a)/2 - 1; i >= 0; i-- { sink(a, i, len(a)) }
	for i := len(a) - 1; i >= 1; i-- {
		a[0], a[i] = a[i], a[0]
		sink(a, 0, i) } return a }
func sink(a []int, i int, length int) {
	for {
		l := i*2 + 1
		r := i*2 + 2
		idx := i
		if l < length && a[l] > a[idx] { idx = l }
		if r < length && a[r] > a[idx] { idx = r }
		if idx == i { break }
		a[i], a[idx] = a[idx], a[i] 
		i = idx } }
```

#### 97. 数组中的第K大的元素（Leetcode215）

```go
// 常规解法
func findKthLargest(nums []int, k int) int { heapSize := len(nums)
    buildMaxHeap(nums, heapSize)
    for i := len(nums) - 1; i >= len(nums) - k + 1; i-- {
        nums[0], nums[i] = nums[i], nums[0]
        heapSize--
        maxHeapify(nums, 0, heapSize) } return nums[0] }
func buildMaxHeap(a []int, heapSize int) {
    for i := heapSize/2; i >= 0; i-- { maxHeapify(a, i, heapSize) } }
func maxHeapify(a []int, i, heapSize int) {
    l, r, largest := i * 2 + 1, i * 2 + 2, i
    if l < heapSize && a[l] > a[largest] { largest = l }
    if r < heapSize && a[r] > a[largest] { largest = r }
    if largest != i { a[i], a[largest] = a[largest], a[i]
        maxHeapify(a, largest, heapSize) } }
```

#### 98. 实现定时任务

```go
func CopyUserInfo() {
   for {
      rows, _ := MysqlClient.Query("SELECT name,mail,department,title FROM UsersInfo")
      userInfos := make(map[int]models.UserInfo)
      userInfo := models.UserInfo{}
      i := 0
      for rows.Next() {
         rows.Scan(&userInfo.Name, &userInfo.Mail, &userInfo.Department, &userInfo.Title)
         userInfos[i] = userInfo
         i++ }
      SetUserNameMail(userInfos)  //save userInfo into Redis
      SetUserDisplaynameMail(userInfos) //save userInfo into Redis
      ticker := time.NewTicker(time.Hour * 12)
      <-ticker.C } }

func startTimer(f func()) {
	go func() { for { f()
			now := time.Now() 
			next := now.Add(time.Hour * 24)
			next = time.Date(next.Year(), next.Month(), next.Day(), 0,0,0,0,next.Location())
			t := time.NewTimer(next.Sub(now))
			<-t.C } }() }
```

#### 99. 两个栈模拟队列

```go
type CQueue struct { stack1, stack2 *list.List }
func Constructor() CQueue {
    return CQueue{ stack1: list.New(), stack2: list.New(), } }
func (this *CQueue) AppendTail(value int)  { this.stack1.PushBack(value) }
func (this *CQueue) DeleteHead() int {
    if this.stack2.Len() == 0 { for this.stack1.Len() > 0 {
            this.stack2.PushBack(this.stack1.Remove(this.stack1.Back())) } }
    if this.stack2.Len() != 0 { e := this.stack2.Back()
        this.stack2.Remove(e)
        return e.Value.(int) } return -1 }
```

#### 100. 二叉树遍历

前序遍历：

```go
func preorderTraversal(root *TreeNode) []int {
    if root == nil{ return nil }
    result:=make([]int,0)
    stack:=make([]*TreeNode,0)
    for root!=nil || len(stack)!=0{ for root !=nil{ result=append(result,root.Val)
            stack=append(stack,root)
            root=root.Left } 
        node:=stack[len(stack)-1]
        stack=stack[:len(stack)-1]
        root=node.Right } return result }
```

中序遍历：

```go
func inorderTraversal(root *TreeNode) []int { result := make([]int, 0)
    if root == nil { return result }
    stack := make([]*TreeNode, 0)
    for len(stack) > 0 || root != nil { for root != nil { stack = append(stack, root)
            root = root.Left }
        val := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, val.Val)
        root = val.Right } return result }
```

后序遍历：

```go
func postorderTraversal(root *TreeNode) []int {
	if root == nil { return nil }
	result := make([]int, 0)
	stack := make([]*TreeNode, 0)
	var lastVisit *TreeNode
	for root != nil || len(stack) != 0 { for root != nil { stack = append(stack, root)
			root = root.Left }
		node:= stack[len(stack)-1]
		if node.Right == nil || node.Right == lastVisit {
			stack = stack[:len(stack)-1] // pop
			result = append(result, node.Val)
			lastVisit = node } else { root = node.Right } } return result }
```