---
layout: post
title: 【面试】谈一谈RPC（一）
tags: networking
---

### 啥是RPC

在[`wikipedia`](https://en.wikipedia.org/wiki/Remote_procedure_call)中的描述中，RPC（remote procedure call）可以被理解为**一个程序去执行在同一共享网络内（或不同地址空间）的程序，但在执行过程中给程序员的感觉就像是在调用本地程序一样**。简单理解来说，就像是下图这样。`A`在执行`Func`函数过程中，想要调用`B`中的`Func1`，此时就可以通过RPC实现方法的调用。

![image-20200813214859064](https://s1.ax1x.com/2020/08/14/d9gAOJ.png)

既然是一方发送请求，另一方接收请求，执行相应内容并返回，因此RPC实际上属于**客户端-服务端**交互的一种方式（在RPC中，调用者是客户端，执行者是服务器），通常是通过请求-响应消息传递系统来实现的。

实际上，当RPC用于调用再同一主机上的两个不同地址空间的程序时，也可看做是一种进程间通信（IPC）的方式。同时，RPC是一种同步的的操作，即在远端程序将结果返回给请求调用的程序的过程中RPC操作是**阻塞**的。

### RPC如何工作

对于RPC的执行过程，我们应该牢记一张图：

<img src="https://media.geeksforgeeks.org/wp-content/uploads/operating-system-remote-procedure-call-1.png" alt="img" style="zoom:50%;" />

该图很好地展示了RPC执行的基本流程。

而执行一次RPC通常需要经历以下步骤。

<img src="https://media.geeksforgeeks.org/wp-content/uploads/operating-system-remote-call-procedure-working.png" alt="img" style="zoom: 50%;" />

我们可以观察到，图中涉及到3个比较重要的内容：

* Client & Server，即发起调用的主机与被调用的主机
* Client Stub & Server Stub，该模块主要负责对来自客户端（服务端）的请求进行**序列化**，以及对来自服务端（客户端）的请求响应进行**反序列化**
* RPC Runtime，即RPC的主要执行过程，可以看到，在Client 的 RPC Runtime 中，在向 Server 发送请求调用的请求后，会一直阻塞等待，知道 Receive 从 Server 反馈回来的结果。

#### 序列化的重要性

我们在调用远程方法的时候，肯定不是所有的函数请求都是请求的空参数的方法。那么该如何传参呢？对于本地调用，只需要把参数压到栈里，然后让函数到栈里读取就可以了。但是RPC通常会应用在跨主机的调用过程中，由于我们的参数需要经过网络传输，所以参数最终必须转换成二进制的数据，而参数是在内存中的，所以我们需要将内存中的参数序列化成我们需要的二进制的形式。这也就是为什么需要**序列化**的原因。

序列化（Serialization）是将程序中的数据结构或对象的状态信息转换为可以存储或者可以通过网络传输的形式的过程，而反序列化（Deserialization）则是序列化的反向过程。我们不考虑语言相关的问题，介绍一下通常情况下序列化的方式都有哪些：

| 数据传输格式    | 类型   | 优点                                                         | 缺点                                                         |
| --------------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| XML             | 文本   | 可读性高，序列化后的数据包含完整的结构，调整不同属性的顺序不影响序列化和反序列化 | 序列化后的数据量大，不支持二进制数据类型                     |
| JSON            | 二进制 | 可读性高，调整不同属性的顺序不影响序列化和反序列化           | 丢弃了类型信息，比如 “price”: 10，对 price 类型的解析有二义性（是 int 还是 double），不支持二进制数据类型 |
| Google Protobuf | 二进制 | 序列化后的数据量较小，序列化和反序列化性能较高               | 可读性较差，向后兼容有一定的限制                             |

#### 通信协议的选择

在通信协议方面，RPC跨越了**传输层**和**应用层**，像 gRPC 就是基于 HTTP 2.0 的协议、Dubbo （分布式微服务框架）在 tcp 基础上研发的应用层传输协议。这么一说，是不是觉得这 RPC 和 HTTP 有啥区别？区别在哪里呢，听我娓娓道来。

#### HTTP与RPC的对比

在网上对于HTTP与RPC的对比千篇一律，这里做一个大致的梳理。对比主要从以下几个方面进行描述：

* 传输协议

  RPC：可以基于HTTP协议，也可以基于TCP协议

  HTTP：基于TCP协议

* 传输效率

  HTTP：如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，来看一个实际的HTTP报文：

  ```html
  HTTP/1.0 200 OK
  Content-Type: text/plain
  Content-Length: 137582
  Expires: Thu, 05 Dec 1997 16:00:00 GMT
  Last-Modified: Wed, 5 August 1996 15:55:28 GMT
  Server: Apache 0.84
  ```

  可以看到报文元数据使用了文本编码方式，非常占字节数。

  RPC：在传输过程中，报头占用的字节数也就只有16个byte，极大地精简了传输内容。

  当然我们也可以使用HTTP2协议执行RPC，同样也可以很好的减小报文体积。

|  1->4 byte  | 5->8 byte |    9->16 byte    | 17-> length+16 byte |
| :---------: | :-------: | :--------------: | :-----------------: |
| length(int) | type(int) | package_id(long) |    package_data     |

>既然说到了RPC会使用HTTP2协议进行传输，面试的时候总免不了被问及HTTP2与HTTP1.1的区别，这里大致描述一下：
>
>HTTP1.1
>
>* 使用摘要算法进行身份验证
>* 默认使用长连接，通过`keep-alive`来设置
>* 增加缓存控制标头来控制缓存失效
>* 支持断点续传，通过`Range`来实现
>* 使用了虚拟网络，一台物理服务器上存在多台虚拟主机，并且共享一个IP地址
>
>HTTP2.0
>
>* 头部压缩，使用HPACK算法进行压缩
>* 二进制格式，使用二进制格式代替ASCII
>* 强化安全，一般都跑在HTTPS上
>* 多路复用，即每一个请求都是用做连接共享

* 性能消耗

  RPC：首先RPC可以实现二进制传输，且序列化过程并不会消耗太多性能，可以实现高效传输。

  HTTP：大部分仍然是以JSON这种文本形式实现的，字节大小和序列化都更加耗时。

* 负载均衡

  RPC：在一些典型的RPC框架中，基本都自带了负载均衡策略。

  HTTP：需要配置Nginx、HAProxy实现负载均衡。

* 服务治理

  RPC：能做到自动通知，不影响上游。

  HTTP：需要事先通知，如修改NGINX配置。

实际上，对于RPC的理解，在[知乎](https://www.zhihu.com/question/41609070/answer/191965937)中有一个非常形象的比喻：

>HTTP好比普通话，RPC好比团伙内部黑话。
>
>讲普通话，好处就是谁都听得懂，谁都会讲。
>
>讲黑话，好处是可以更精简、更加保密、更加可定制，坏处就是要求“说”黑话的那一方（client端）也要懂，而且一旦大家都说一种黑话了，换黑话就困难了

以上就是一些关于RPC定义及概念的内容，在后面将会对具体实现以及典型框架进行进一步的描述。

好活，当赏~