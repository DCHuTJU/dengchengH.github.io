---
layout: post
title: 【面试】谈一谈RPC（一）
tags: networking
---

### 啥是RPC

在[`wikipedia`](https://en.wikipedia.org/wiki/Remote_procedure_call)中的描述中，RPC（remote procedure call）可以被理解为**一个程序去执行在同一共享网络内（或不同地址空间）的程序，但在执行过程中给程序员的感觉就像是在调用本地程序一样**。简单理解来说，就像是下图这样。`A`在执行`Func`函数过程中，想要调用`B`中的`Func1`，此时就可以通过RPC实现方法的调用。

![image-20200813214859064](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200813214859064.png)

既然是一方发送请求，另一方接收请求，执行相应内容并返回，因此RPC实际上属于**客户端-服务端**交互的一种方式（在RPC中，调用者是客户端，执行者是服务器），通常是通过请求-响应消息传递系统来实现的。

实际上，当RPC用于调用再同一主机上的两个不同地址空间的程序时，也可看做是一种进程间通信（IPC）的方式。同时，RPC是一种同步的的操作，即在远端程序将结果返回给请求调用的程序的过程中RPC操作是**阻塞**的。

### RPC如何工作

对于RPC的执行过程，我们应该牢记一张图：

<img src="https://media.geeksforgeeks.org/wp-content/uploads/operating-system-remote-procedure-call-1.png" alt="img" style="zoom:50%;" />

该图很好地展示了RPC执行的基本流程。

而执行一次RPC通常需要经历以下步骤。

<img src="https://media.geeksforgeeks.org/wp-content/uploads/operating-system-remote-call-procedure-working.png" alt="img" style="zoom: 50%;" />

我们可以观察到，图中涉及到3个比较重要的内容：

* Client & Server，即发起调用的主机与被调用的主机
* Client Stub & Server Stub，该模块主要负责对来自客户端（服务端）的请求进行**序列化**，以及对来自服务端（客户端）的请求响应进行**反序列化**
* RPC Runtime，即RPC的主要执行过程，可以看到，在Client 的 RPC Runtime 中，在向 Server 发送请求调用的请求后，会一直阻塞等待，知道 Receive 从 Server 反馈回来的结果。

#### 序列化的重要性

我们在调用远程方法的时候，肯定不是所有的函数请求都是请求的空参数的方法。那么该如何传参呢？对于本地调用，只需要把参数压到栈里，然后让函数到栈里读取就可以了。但是RPC通常会应用在跨主机的调用过程中，由于我们的参数需要经过网络传输，所以参数最终必须转换成二进制的数据，而参数是在内存中的，所以我们需要将内存中的参数序列化成我们需要的二进制的形式。这也就是为什么需要**序列化**的原因。

序列化（Serialization）是将程序中的数据结构或对象的状态信息转换为可以存储或者可以通过网络传输的形式的过程，而反序列化（Deserialization）则是序列化的反向过程。我们不考虑语言相关的问题，介绍一下通常情况下序列化的方式都有哪些：

| 数据传输格式    | 类型   | 优点                                                         | 缺点                                                         |
| --------------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| XML             | 文本   | 可读性高，序列化后的数据包含完整的结构，调整不同属性的顺序不影响序列化和反序列化 | 序列化后的数据量大，不支持二进制数据类型                     |
| JSON            | 二进制 | 可读性高，调整不同属性的顺序不影响序列化和反序列化           | 丢弃了类型信息，比如 “price”: 10，对 price 类型的解析有二义性（是 int 还是 double），不支持二进制数据类型 |
| Google Protobuf | 二进制 | 序列化后的数据量较小，序列化和反序列化性能较高               | 可读性较差，向后兼容有一定的限制                             |

#### 通信协议的选择

在通信协议方面，RPC跨越了**传输层**和**应用层**，像 gRPC 就是基于 HTTP 2.0 的协议、Dubbo （分布式微服务框架）在 tcp 基础上研发的应用层传输协议。这么一说，是不是觉得这 RPC 和 HTTP 有啥区别？区别在哪里呢，听我娓娓道来。

#### HTTP与RPC的优缺点的对比

